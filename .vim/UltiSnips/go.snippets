# x. snippet template {{{

# snippet x. "x" w
# x.
# endsnippet

# }}}
# operater {{{
# +    sum                    integers, floats, complex values, strings
# -    difference             integers, floats, complex values
# *    product                integers, floats, complex values
# /    quotient               integers, floats, complex values
# %    remainder              integers

# &    bitwise AND            integers
# |    bitwise OR             integers
# ^    bitwise XOR            integers
# &^   bit clear (AND NOT)    integers

# <<   left shift             integer << integer >= 0
# >>   right shift            integer >> integer >= 0

# shorthand variable declaration
snippet : "name := value"
${1} := ${0}
endsnippet

snippet = "name = value"
${1} = ${0}
endsnippet

snippet += "name += value"
${1} += ${0}
endsnippet

snippet -= "name -= value"
${1} -= ${0}
endsnippet

snippet *= "name *= value"
${1} -= ${0}
endsnippet

snippet /= "name /= value"
${1} /= ${0}
endsnippet


snippet eq "name == value"
${1} == ${0}
endsnippet

snippet ne "name != value"
${1} != ${0}
endsnippet

snippet lt "name < value"
${1} < ${0}
endsnippet

snippet le "name <= value"
${1} <= ${0}
endsnippet

snippet gt "name > value"
${1} > ${0}
endsnippet

snippet ge "name >= value"
${1} >= ${0}
endsnippet
# }}}
# keyword {{{
# break        default      func         interface    select
# case         defer        go           map          struct
# chan         else         goto         package      switch
# const        fallthrough  if           range        type
# continue     for          import       return       var

snippet br "break" 
break 
endsnippet

# case
snippet ca "case ...:"
case ${1:value}:
	${0:${VISUAL}}
endsnippet

# channel
snippet ch "chan Type"
chan ${0:int}
endsnippet

# constant
snippet co "const XXX Type = ..."
const ${1:NAME_Type} = ${0:value}
endsnippet

# constants
snippet cos "const ( ... )"
const (
	${1:NAME_type} = ${2:value}
	${0}
)
endsnippet

# constants with iota
snippet ci "const ( ... = iota )"
const (
	${1:NAME} ${2:Type} = iota
	${0}
)
endsnippet

# continue
snippet cn "continue"
continue
endsnippet

# default case
snippet de "default: ..."
default:
	${0:${VISUAL}}
endsnippet

# defer
snippet df "defer someFunction()"
defer ${1:func}
endsnippet

snippet fs "for select"
for {
    select {
	case ${2:${1:result} := }<- ${3:channel}:
	    ${0}
    }
}
endsnippet

snippet sl "select {case ...}"
select {
    case ${2:${1:result} := }<- ${3:channel}:
	${0}
}
endsnippet


# if condition
snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

# if initiate condition
snippet i; "if; ... { ... }"
if ${1:_, ok} := ${2:map[key]}; ${3:condition} {
	${0:${VISUAL}}
}
endsnippet


# else snippet
snippet el "else { ... }"
else {
	${0:${VISUAL}}
}
endsnippet

# if...else... condition
snippet ie "if ... else ..."
if ${1:condition} {
	${2:${VISUAL}}
} else {
	${0}
}
endsnippet

# if...else if ... condition
snippet iei "if ... else if ..."
if ${1:condition} {
	${2:${VISUAL}}
} else if ${3:condition} {
	${0}
}
endsnippet

snippet r "return" b
return 
endsnippet

snippet re "return err" b
return err
endsnippet

snippet rn "return nil" b
return nil
endsnippet

snippet r, "return nil, err" b
return ${1:nil}, ${2:err}
endsnippet

snippet ra "range" 
range 
endsnippet

# for range loop
snippet rk "for v := range items { ... }"
for ${2:k} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

# for range loop
snippet rv "for k, v := range items { ... }"
for _, ${2:v} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

# switch
snippet sw "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
    ${3}
default:
    ${0}
}
endsnippet

# map
snippet ma "map[Type]Type" w
map[${1:string}]${0:string}
endsnippet

# package
snippet pa "package ..." b
// Package $1 provides ${2:...}
package ${1:main}
${0}
endsnippet



# struct
snippet s "type T struct { ... }" b
type ${1:Type} struct {
    ${0:/* TODO: add fields */}
}
endsnippet



# full interface snippet
snippet i "interface I { ... }" b
type ${1:Interface} interface {
    ${0:/* TODO: add methods */}
}
endsnippet


# type
snippet ty "type" b
type
endsnippet

snippet st "struct" 
struct{${0}}
endsnippet

snippet in "interface" 
interface{${0}}
endsnippet



# variable declaration
snippet v "var x Type" b
var ${0:name_type}
endsnippet

snippet vv "var x Type = value" b
var ${1:name_type} = ${0:value}
endsnippet


# variables declaration
snippet vs "var ( name type = value )" b
var (
    ${0:name}
)
endsnippet


# }}}
# built-in function {{{
# Functions:
# 	append cap clear close complex copy delete imag len
# 	make max min new panic print println real recover

# append
snippet ap "append(slice, value)"
append(${1:slice}, ${0:value})
endsnippet


# copy
snippet cp "copy(any)"
copy(${0:any})
endsnippet

# delete
snippet dl "delete(any)"
delete(${0:any})
endsnippet

# len
snippet l "len(any)"
len(${0:any})
endsnippet

# make
snippet mk "make(any)"
make(${0:any})
endsnippet


# panic
snippet pn "panic(err)"
panic(${1:err})
${0}
endsnippet
# }}}
# data type {{{
# Types:
# 	any bool byte comparable
# 	complex64 complex128 error float32 float64
# 	int int8 int16 int32 int64 rune string
# 	uint uint8 uint16 uint32 uint64 uintptr

# Constants:
# 	true false iota

# Zero value:
# 	nil

# Functions:
# 	append cap clear close complex copy delete imag len
# 	make max min new panic print println real recover

# snippet a "any" w
# any
# endsnippet
context "re.search(r'\S',snip.before[:-2]) and re.match(r'[^\w\[]',snip.before[-3])"
snippet /b[ol]/ "bool" rwe
bool
endsnippet

context "re.search(r'\S',snip.before[:-2]) and re.match(r'[^\w\[]',snip.before[-3])"
snippet cm "comparable" we
comparable
endsnippet

context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet a "any" we
any
endsnippet

context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet b "byte" we
byte
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet e "error" we
error
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet i "int" we
int
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet u "uint" we
uint
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet s "string" we
string
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet t "true" we
true
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet f "false" we
false
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet n "nil" we
nil
endsnippet


context "re.search(r'\S',snip.before[:-1]) and re.match(r'[^\w\[]',snip.before[-2])"
snippet fl "float" we
float
endsnippet


snippet [b "[]byte"  i
[]byte
endsnippet

snippet [s "[]string" i
[]string
endsnippet

snippet [i "[]int" i
[]int
endsnippet

snippet [u "[]uint" i
[]uint
endsnippet


snippet [f "[]float" i
[]float
endsnippet



# json field tag
snippet `j "\`json:key\`" 
\`json:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# yaml field tag
snippet `y "\`yaml:key\`" 
\`yaml:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

#  field tag
snippet `f "\`input:key\`" 
\`${1:form}:"${2:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# }}}
# error {{{
# error snippet
snippet e "if err != nil { return  err }" b
if err != nil {
    ${1:return err}
}
${0}
endsnippet


# error multiple return
snippet e, "Error return with two return values" b
if err != nil {
	return ${1:nil}, ${2:err}
}
${0}
endsnippet

# error log.Fatal
snippet eF "if err != nil { log.Fatal(err)}" b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error log.Fatal
snippet ep "if err != nil { log.Println(err)}" b
if err != nil {
	log.Println(err)
}
${0}
endsnippet

# error t.Fatal
snippet etf "if err != nil { t.Fatal(err)" b
if err != nil {
    t.Fatal(${1:err})
}
${0}
endsnippet

# }}}
# function and method {{{
# function
snippet fn "func Function(...) [error] { ... }" b
// $1 ${4:DOC ...}
func ${1:name}(${2:params}) ${3:error} {
    ${0:${VISUAL}}
}
endsnippet

snippet af "func(){ ... }" w
func() { 
    ${0:${VISUAL}}
}
endsnippet

snippet aF "func(with parameters) [error] { ... }" w
func(${1:params}) ${2:error} { 
	${0:${VISUAL}}
}
endsnippet


snippet gf "func Function[generics] (...) [error] { ... }" b
// $1 ${5:DOC ...}
func ${1:name}[${2:constraints}](${3:params}) ${4:error} {
	${0:${VISUAL}}
}
endsnippet

# method
snippet me "func (self Type) Method(...) [error] { ... }" b
// $3 ${6:DOC ...}
func (${1:receiver} ${2:type}) ${3:name}(${4:params}) ${5:error} {
	${0:${VISUAL}}
}
endsnippet
# }}}
# function call {{{
snippet .c ".Close()" i
.Close()
endsnippet
# }}}
# standard library {{{
# b. bytes {{{
snippet bs "bytes" w
bytes
endsnippet

snippet b. "bytes" w
bytes.
endsnippet

# }}}
# c. context {{{
snippet ct "context"
context
endsnippet

snippet c. "context"
context.
endsnippet


snippet .ct ".Context()" i
.Context()
endsnippet


snippet c.wc "context.WithValue"
${1:ctx}.WithContext(${0:ctx})
endsnippet

snippet c.wv "context.WithValue"
context.WithValue(${1:r.Context()}, ${2:key}, ${0:val})
endsnippet
# }}}
# e. errors {{{

snippet es "errors" w
errors
endsnippet

snippet e. "errors" w
errors.
endsnippet


snippet eis "if errors.Is(err,...)"
if errors.Is(err,${1:some error}) {
    ${0:handle err}
}
endsnippet

snippet eas "if errors.As(err,...)"
if errors.As(err,${1:some error}) {
    ${0:handle err}
}
endsnippet
# }}}
# f. fmt {{{

# Fmt Printf debug
snippet pf "fmt.Printf(...)"
fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})
endsnippet

# Fmt Println debug
snippet pl "fmt.Println(...)"
fmt.Println("${1:${VISUAL}}")
endsnippet

# Fmt Errorf debug
snippet ef "fmt.Errorf(...)"
fmt.Errorf("${1:${VISUAL}}")
endsnippet

snippet Ff "fmt.Printf(...)"
fmt.Fprintf(${1:w},"${2: = %+v\n"}, ${0:${VISUAL}})
endsnippet

snippet Fl "fmt.Printf(...)"
fmt.Fprintln(${1:w}, ${0:${VISUAL}})
endsnippet



# }}}
# h. http {{{
# func {{{
snippet hf "http.HandlerFunc" b
// $1 ${2:DOC ...}
func ${1:HandlerFunc}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintln(w, "hello world")}
}
endsnippet


snippet hm "http.HandlerFunc method" b
// $3 ${4:DOC ...}
func (${1:receiver} ${2:type}) ${3:HandlerFunc}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintln(w, "hello world")}
}
endsnippet

snippet mf "middleware" b
// $1 ${2:DOC ...}
func ${1:myMiddleware}(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		${0:// TODO: Execute our middleware logic here...}

		h.ServeHTTP(w, r) 
    })
}
endsnippet

# method
snippet mm "func (self Type) middleware(h http.Handler) http.Handler" b
// $3 ${4:DOC ...}
func (${1:receiver} ${2:type}) ${3:myMiddleware}(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		${0:// TODO: Execute our middleware logic here...}

		h.ServeHTTP(w, r) 
	})
}

endsnippet
# }}}
snippet h. "http." w
http.
endsnippet

snippet h.hf "call http.HandlerFunc" 
http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintln(w, "hello world")}
})
endsnippet

snippet h.hl "http.Handler" w
http.Handler
endsnippet

snippet h.h "http.Header" w
http.Header
endsnippet

snippet h.rq "http.Request" w
http.Request
endsnippet

snippet h.nrq "http.NewRequest(...)"
http.NewRequest(http.${1:MethodGet},"${2:/}",${3:body})
endsnippet

snippet h.rp "http.Response" w
http.Response
endsnippet

snippet h.g "http.MethodGet" w
http.MethodGet
endsnippet

snippet h.p "http.MethodPost" w
http.MethodPost
endsnippet

snippet h.ok "http.StatusOK" w
http.StatusOK
endsnippet

snippet h.nf "http.NotFound" w
http.StatusNotFound
endsnippet

snippet h.ise "http.StatusInternalServerError" w
http.StatusInternalServerError
endsnippet


snippet h.br "http.StatusBadRequest" w
http.StatusBadRequest
endsnippet

snippet h.ue "http.StatusUnprocessableEntity" w
http.StatusUnprocessableEntity
endsnippet

snippet h.so "http.StatusSeeOther" w
http.StatusSeeOther
endsnippet

snippet h.st "http.StatusText(...)" w
http.StatusText(${0:StatusCode})
endsnippet

snippet h.rd "http.Redirect(w,r,url,code)" w
http.Redirect(w,r,${1:url},http.StatusSeeOther)
endsnippet




# }}}
# ht. httptest {{{
snippet ht. "httptest." w
httptest.
endsnippet

snippet ht.nrr "httptest.NewRecorder()"
httptest.NewRecorder()
endsnippet

# }}}
# i. io {{{
# snippet i. "io" w
# io.
# endsnippet

snippet i.ra "io.ReadAll(...)" w
io.ReadAll(${1:Reader})
endsnippet
# }}}
# o. os {{{
# snippet o. "os" w
# os.
# endsnippet

snippet o.rf "os.ReadFile" w
os.ReadFile(${0:filename})
endsnippet

# }}}
# r. regexp {{{
snippet re "regexp" w
regexp
endsnippet
# }}}
# s. strings {{{
snippet ss "strings" w
strings
endsnippet

snippet s. "strings" w
strings.
endsnippet

# }}}
# sv. strconv {{{
snippet sv "strconv" w
strconv
endsnippet

snippet a2i "strconv.Atoi(...)" w
strconv.Atoi(${0:"string"})
endsnippet

# }}}
# sq. sql {{{

snippet sq.o "sql.Open(...)" w
sql.Open(${1:driverName}, ${2:dataSourceName})${0}
endsnippet


# }}}
# t. time {{{

snippet tm "time" w
time
endsnippet

snippet now "time.Now()" w
time.Now()
endsnippet

# }}}
# te. testing {{{
snippet te "testing" w
testing
endsnippet

snippet te. "testing" w
testing.
endsnippet


snippet tf "func TestXYZ(t *testing.T) { ... }" b
// Test$1 ${2:DOC ...}
func Test${1:Function}(t *testing.T) {
	${0:${VISUAL}}
}
endsnippet

# test t.Run
snippet t.r "call t.Run(XYZ, func(t *testing.T){ ... })"
t.Run("${1:name}", func(t *testing.T){
    ${0:/* TODO: test */}
})
endsnippet

# test table snippet
snippet tt "test table"
var tests = []struct{
    name string
    ${1:any}
}{
    {
	name: "${2:name}",
	${3:any_1},
    },
}
for _, v := range tests {
    t.Run(v.name, func(t *testing.T){

    ${0:/* TODO: test_body */}

    })
}
endsnippet

snippet Equal "func Equal[T comparable](t *testing.T, actual, expected T)" b
// Equal used for test 
func Equal[T comparable](t *testing.T, actual, expected T) {

	t.Helper()

	if actual != expected {
		t.Errorf("actual: %v; expected: %v", actual, expected)
	}

}
endsnippet


# }}}
# u. url {{{
# snippet u. "url." w
# url.
# endsnippet

snippet u.v "url.Values" w
url.Values
endsnippet

# }}}
# }}}
